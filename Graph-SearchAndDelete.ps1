#
# Graph-SearchAndDelete.ps1
#
# By Jim Martin, Microsoft Ltd. 2013-2023. Use at your own risk.  No warranties are given.
#
#  DISCLAIMER:
# THIS CODE IS SAMPLE CODE. THESE SAMPLES ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.
# MICROSOFT FURTHER DISCLAIMS ALL IMPLIED WARRANTIES INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR OF FITNESS FOR
# A PARTICULAR PURPOSE. THE ENTIRE RISK ARISING OUT OF THE USE OR PERFORMANCE OF THE SAMPLES REMAINS WITH YOU. IN NO EVENT SHALL
# MICROSOFT OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
# BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR OTHER PECUNIARY LOSS) ARISING OUT OF THE USE OF OR INABILITY TO USE THE
# SAMPLES, EVEN IF MICROSOFT HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. BECAUSE SOME STATES DO NOT ALLOW THE EXCLUSION OR LIMITATION
# OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES, THE ABOVE LIMITATION MAY NOT APPLY TO YOU.


param(
    [Parameter(Mandatory=$false, HelpMessage="The AppCredentialType parameter specifies whether to use a client secret or certificate.")][ValidateSet('ClientSecret','Certificate')] [string]$AppCredentialType="ClientSecret",
    [Parameter(Mandatory=$true, HelpMessage="The Mailbox parameter specifies the mailbox to perform the search against.")] [string]$Mailbox,
    [Parameter(Mandatory=$false, HelpMessage="The CreatedBefore parameter searches for only messages created before this date.")] [datetime]$CreatedBefore,
    [Parameter(Mandatory=$false, HelpMessage="The CreatedAfter parameter searches for only messages created after this date.")] [datetime]$CreatedAfter,
    [Parameter(Mandatory=$False,HelpMessage="The Subject parameter searches for only messages containing this string in the subject.")] [string]$Subject,
    [Parameter(Mandatory=$False,HelpMessage="The Sender parameter searches for only messages sent by this sender.")] [string]$SenderAddress,
    [Parameter(Mandatory=$False,HelpMessage="The MessageBody parameter specifies the body string used by the search.")] [string]$MessageBody,
    [Parameter(Mandatory=$true,HelpMessage="The OutputPath parameter specifies the path for report generated by the script.")] [string]$OutputPath,
    [Parameter(Mandatory=$False,HelpMessage="The DeleteContent parameter is a switch to delete the items found in the search results (moved to Deleted Items).")][switch]$DeleteContent,
    [Parameter(Mandatory=$false,HelpMessage="The SearchDumpster parameter is a switch to search the recoverable items.")] [switch]$SearchDumpster,
    [Parameter(Mandatory=$False,HelpMessage="The IncludeFolderList parameter specifies the folder(s) to be searched (if not present, then the Inbox folder will be searched).  Any exclusions override this list.")] $IncludeFolderList,
    [Parameter(Mandatory=$False,HelpMessage="The ExcludeFolderList parameter specifies the folder(s) to be excluded (these folders will not be searched).")] $ExcludeFolderList,
    [Parameter(Mandatory=$False,HelpMessage="The ProcessSubfolders parameter is a switch to enable searching the subfolders of any specified folder.")] [switch]$ProcessSubfolders,
    
#>** OAUTH PARAMETERS START **#
    [Parameter(Mandatory=$False,HelpMessage="The OAuthClientId specifies the client Id that this script will identify as.  Must be registered in Azure AD.")] [string]$OAuthClientId = "2e542266-3c04-4354-8965-aeafccd61976",
    [Parameter(Mandatory=$False,HelpMessage="The OAuthTenantId specifies the tenant Id (application must be registered in the same tenant being accessed).")] [string]$OAuthTenantId = "9101fc97-5be5-4438-a1d7-83e051e52057",
    [Parameter(Mandatory=$False,HelpMessage="The OAuthRedirectUri specifies the redirect Uri of the Azure registered application.")] [string]$OAuthRedirectUri = "msal9b38df47-ae02-4777-9edb-4ba2b727bcc4://auth",
    [Parameter(Mandatory=$False,HelpMessage="The OAuthSecretKey specifies the secret key if using application permissions.")] [string]$OAuthSecretKey = "qau8Q~5L23ScrpM3b2tcdeylQPpRSeFrfyhxKcgP",
    [Parameter(Mandatory=$False,HelpMessage="The OAuthCertificate specifies the certificate if using application permissions.  Certificate auth requires MSAL libraries to be available.")] $OAuthCertificate = $null,
#>** OAUTH PARAMETERS END **#
    [Parameter(Mandatory=$False,HelpMessage="The LogFile parameter specifies the Log file path - activity is logged to this file if specified.")][string]$LogFile = "",
    [Parameter(Mandatory=$False,HelpMessage="The VerboseLogFile parameter is a switch that enables verbose log file.  Verbose logging is written to the log whether -Verbose is enabled or not.")]	[switch]$VerboseLogFile,
    [Parameter(Mandatory=$False,HelpMessage="The DebugLogFile parameter is a switch that enables debug log file.  Debug logging is written to the log whether -Debug is enabled or not.")][switch]$DebugLogFile,
    [Parameter(Mandatory=$False,HelpMessage="The FastFileLogging parameter is a switch that if selected, an optimised log file creator is used that should be signficantly faster (but may leave file lock applied if script is cancelled).")][switch]$FastFileLogging
    
)

#>** LOGGING FUNCTIONS START **#
Function LogToFile([string]$Details)
{
	if ( [String]::IsNullOrEmpty($LogFile) ) { return }
	"$([DateTime]::Now.ToShortDateString()) $([DateTime]::Now.ToLongTimeString())   $Details" | Out-File $LogFile -Append
}

Function UpdateDetailsWithCallingMethod([string]$Details)
{
    # Update the log message with details of the function that logged it
    $timeInfo = "$([DateTime]::Now.ToShortDateString()) $([DateTime]::Now.ToLongTimeString())"
    $callingFunction = (Get-PSCallStack)[2].Command # The function we are interested in will always be frame 2 on the stack
    if (![String]::IsNullOrEmpty($callingFunction))
    {
        return "$timeInfo [$callingFunction] $Details"
    }
    return "$timeInfo $Details"
}

Function LogToFile([string]$logInfo)
{
    if ( [String]::IsNullOrEmpty($LogFile) ) { return }
    
    if ($FastFileLogging)
    {
        # Writing the log file using a FileStream (that we keep open) is significantly faster than using out-file (which opens, writes, then closes the file each time it is called)
        $fastFileLogError = $Error[0]
        if (!$script:logFileStream)
        {
            # Open a filestream to write to our log
            Write-Verbose "Opening/creating log file: $LogFile"
            $script:logFileStream = New-Object IO.FileStream($LogFile, ([System.IO.FileMode]::Append), ([IO.FileAccess]::Write), ([IO.FileShare]::Read) )
            if ( $Error[0] -ne $fastFileLogError )
            {
                $FastFileLogging = $false
                Write-Host "Fast file logging disabled due to error: $Error[0]" -ForegroundColor Red
                $script:logFileStream = $null
            }
        }
        if ($script:logFileStream)
        {
            if (!$script:logFileStreamWriter)
            {
                $script:logFileStreamWriter = New-Object System.IO.StreamWriter($script:logFileStream)
            }
            $script:logFileStreamWriter.WriteLine($logInfo)
            $script:logFileStreamWriter.Flush()
            if ( $Error[0] -ne $fastFileLogError )
            {
                $FastFileLogging = $false
                Write-Host "Fast file logging disabled due to error: $Error[0]" -ForegroundColor Red
            }
            else
            {
                return
            }
        }
    }

	$logInfo | Out-File $LogFile -Append
}

Function Log([string]$Details, [ConsoleColor]$Colour)
{
    if ($Colour -eq $null)
    {
        $Colour = [ConsoleColor]::White
    }
    $Details = UpdateDetailsWithCallingMethod( $Details )
    Write-Host $Details -ForegroundColor $Colour
    LogToFile $Details
}
Log "$($MyInvocation.MyCommand.Name) version $($script:ScriptVersion) starting" Green

Function LogVerbose([string]$Details)
{
    Write-Verbose $Details
    #if ( !$VerboseLogFile -and !$DebugLogFile -and ($VerbosePreference -eq "SilentlyContinue") ) { return }
    LogToFile $Details
}

Function LogDebug([string]$Details)
{
    Write-Debug $Details
    if (!$DebugLogFile -and ($DebugPreference -eq "SilentlyContinue") ) { return }
    LogToFile $Details
}

$script:LastError = $Error[0]
Function ErrorReported($Context)
{
    # Check for any error, and return the result ($true means a new error has been detected)

    # We check for errors using $Error variable, as try...catch isn't reliable when remoting
    if ([String]::IsNullOrEmpty($Error[0])) { return $false }

    # We have an error, have we already reported it?
    if ($Error[0] -eq $script:LastError) { return $false }

    # New error, so log it and return $true
    $script:LastError = $Error[0]
    if ($Context)
    {
        Log "ERROR ($Context): $($Error[0])" Red
    }
    else
    {
        $log = UpdateDetailsWithCallingMethod("ERROR: $($Error[0])")
        Log $log Red
    }
    return $true
}

Function ReportError($Context)
{
    # Reports error without returning the result
    ErrorReported $Context | Out-Null
}
#>** LOGGING FUNCTIONS END **#


function CreateOutputFile{
    # Create the output file
    # If an Output path is defined via the parameter, first check if the provided Output Path exists, if not exit the script
    if(!(Test-Path -Path $OutputPath))    {
        Write-Error "The provided OutputPath does not exist, exiting script" -ForegroundColor Red
        Exit
    }
    else    {
        # The path exists, so creating the Output file
        $Script:OutputStream = New-Item -Path $OutputPath -Type file -Force -Name $($Script:FileName) -ErrorAction Stop -WarningAction Stop
        # Add the header to the csv file
        $strCSVHeader = $Script:csvOuput = "Sender,Subject,ReceivedDateTime,Folder"
        Add-Content $Script:OutputStream $strCSVHeader
    }
}

function Test-InstalledModules{
    #Test if the required module is installed, if not exit the script and print a help message
    if(-not (Get-InstalledModule -Name MSAL.PS -MinimumVersion 4.37.0.0)) {
        Write-Host "This script requires 'MSAL.PS' module with Minimum version 4.37.0.0" -ForegroundColor Red
        Write-Host "Please install the required 'MSAL.PS' module from the PSGallery repository by running command:" -ForegroundColor Red
        Write-Host "Install-Module -Name MSAL.PS -MinimumVersion '4.37.0.0' -Repository:PSGallery" -ForegroundColor Red
        exit
    }
}

function GetOAuthToken {
    Log "Obtaining access token to use for the Graph API calls." Cyan
    if($null -notlike $OAuthCertificate) {
        $Script:OAuthToken = Get-MsalToken -ClientId $OAuthClientId -RedirectUri $RedirectUri -TenantId $OAuthTenantId -Scopes $Script:Scope -AzureCloudInstance AzurePublic -ClientCertificate (Get-Item Cert:\CurrentUser\My\$CertificateThumbprint)
    }
    else {
        $OAuthSecretKey = $OAuthSecretKey | ConvertTo-SecureString -Force -AsPlainText
        $Script:OAuthToken = Get-MsalToken -ClientId $OAuthClientId -ClientSecret $OAuthSecretKey -TenantId $OAuthTenantId -Scopes $Script:Scope -AzureCloudInstance AzurePublic
    }
    $Script:OAuthTokenAcquireTime = [DateTime]::UtcNow
    return $Script:OAuthToken.AccessToken
}

function Send-GraphRequest{
    param(
        [Parameter(Mandatory=$true, HelpMessage="The Uri parameter specifies the request uri.")] [string] $Uri,
        [Parameter(Mandatory=$false, HelpMessage="The HttpMethod parameter specifies the method for the request.")] [string] $HttpMethod="GET"
    )
    if ([DateTime]::UtcNow.AddSeconds(-10) -gt $Script:OAuthToken.ExpiresOn.UtcDateTime) {
        Write-Host "Acquiring new token using the refresh token..." -ForegroundColor Cyan
        $body = @{grant_type="refresh_token";scope=$Script:Scope;client_id=$OAuthClientId;refresh_token=$Script:OAuthToken.refresh_token}
        $Script:OAuthToken = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$OAuthTenantId/oauth2/v2.0/token" -Body $body
        $Script:Token = $Script:OAuthToken.access_token
        $script:OAuthTokenAcquireTime = [DateTime]::UtcNow
        $Headers = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $Script:Token"
        }        
    }
    else {
        $Headers = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $Script:Token"
        }
    }
    
    $MessageParams = @{
        "URI"         = $Uri
        "Headers"     = $Headers
        "Method"      = $HttpMethod
        "ContentType" = "application/json"
        "UseBasicParsing" = $null
        }

        $Results = ""
        $StatusCode = ""

        do {
            try {
                $Results = Invoke-RestMethod @Messageparams # -Headers $Headers -Uri $Uri -UseBasicParsing -Method "GET" -ContentType "application/json"
                $StatusCode = $Results.StatusCode
            } 
            catch {
                $StatusCode = $_.Exception.Response.StatusCode.value__
                if ($StatusCode -eq 429) {
                    Write-Warning "Request being throttled. Sleeping for 50 seconds..."
                    Start-Sleep -Seconds 50
                }
                elseif ($StatusCode -eq 504) {
                    Write-Warning "Request received timeout error. Retrying in 20 seconds..."
                    Start-Sleep -Seconds 20
                }
                else {
                    Write-Error $_.Exception
                }
            }
        } 
        while ($StatusCode -eq 429)
        #$Response = Invoke-RestMethod @Messageparams
        return $Results

}

function GetFolderList {
    Log "Getting a list of mail folders in the mailbox." Cyan
    if($SearchDumpster) {
        $FolderResults = Send-GraphRequest -Uri "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/RecoverableItemsRoot/childfolders/?includeHiddenFolders=true"
    }
    else {
        #$FolderResults = Send-GraphRequest -Uri "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/Root/childfolders/?$Top=500"
        $FolderResults = Send-GraphRequest -Uri "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/delta"
    }
    foreach($Result in $FolderResults.Value){
        $FolderList.Add($Result) | Out-Null
    }
    while($null -ne $FolderResults.'@odata.nextLink'){
        $FolderResults = Send-GraphRequest -Uri $FolderResults.'@odata.nextLink'
        foreach($Result in $FolderResults.Value){
            $FolderList.Add($Result) | Out-Null
        }
    }
    if ($IncludeFolderList) {
        # We are searching specific folders
        foreach ($includedFolder in $IncludeFolderList) {
            $folder = GetFolder -IncludeFolder $includedFolder
            if($folder) {
                $Script:SearchFolderList.Add($folder) | Out-Null
            }
        }
        if($ProcessSubfolders){
            foreach($folder in $FolderList){
                if($folder.parentFolderId -eq $Script:ParentFolder) {
                    $Script:SearchFolderList.Add($folder) | Out-Null
                }
            }
        }
    }
    else {
        $Script:SearchFolderList = $FolderList
    }
    
    if($ExcludeFolderList) {
        foreach($excludedFolder in $ExcludeFolderList){
            $folder = GetFolder -IncludeFolder $excludedFolder
            if($folder) {
                $Script:SearchFolderList.Remove($folder)
            }
        }
    }
    
}
function GetFolder{
    param (
    [Parameter(Mandatory=$true)] [string]$IncludeFolder
    )
    foreach($folder in $FolderList) {
        if($folder.DisplayName -eq $IncludeFolder) {
            $Script:ParentFolder = $folder.id
            return $folder
        }
    }
}

function SearchMailbox {
    Log "Performing search against the mailbox..." Cyan
    foreach($folder in $Script:SearchFolderList){
        $Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/$($folder.id)/messages?"
        $UriFilter = CreateSearchQuery
    
        # Finalize the Uri with the final filter/search settings
        $Uri = $Uri + $UriFilter
        Log([string]::Format("Performing search against the {0} folder...", $folder.displayName))
        LogVerbose([string]::Format("Performing query using: {0}", $Uri))
    
        # Search the mailbox for items

        $SearchItems = Send-GraphRequest -Uri $Uri
        foreach($Result in $SearchItems.Value){
            $Script:SearchResults.Add($Result) | Out-Null
        }
        while($null -ne $SearchItems.'@odata.nextLink'){
            $PageNumber = $PageNumber + $SearchItems.value.Count
            $SearchItems = Send-GraphRequest -Uri $SearchItems.'@odata.nextLink'
            foreach($Result in $SearchItems.Value){
                $Script:SearchResults.Add($Result) | Out-Null
            }
        }
    }
}

function CreateSearchQuery {
    if($null -like $MessageBody) {
        LogVerbose "Creating a query using the filter function."
        if($null -notlike $Subject) {
            $UriFilter = "filter=contains(subject,`'$Subject`')&`$top=500&`$from=$PageNumber"
        }
    
        if($null -notlike $CreatedBefore){
            $TempStartDate = [datetime]$CreatedBefore
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchStartDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if($UriFilter -like '*filter*'){
                $UriFilter = $UriFilter.Replace('filter=', "filter=receivedDateTime le $($SearchStartDate) and ")
            }
            else {
                $UriFilter = "filter=receivedDateTime le $($SearchStartDate)&`$top=500&`$from=$PageNumber"
            }
        }
    
        if($null -notlike $CreatedAfter){
            $TempEndDate = [datetime]$CreatedAfter
            $TempEndDate = $TempEndDate.ToUniversalTime()
            $SearchEndDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempEndDate
            if($UriFilter -like '*filter*'){
                $UriFilter = $UriFilter.Replace('filter=', "filter=receivedDateTime ge $($SearchEndDate) and ")
            }
            else {
                $UriFilter = "filter=receivedDateTime ge $($SearchEndDate)&`$top=500&`$from=$PageNumber"
            }
        }
    
        if($null -notlike $SenderAddress) {
            if($UriFilter -like '*filter*'){
                $UriFilter = $UriFilter.Replace('filter=', "filter=(from/emailAddress/address) eq `'$SenderAddress`' and ")
            }
            else {
                $UriFilter = "filter=(from/emailAddress/address) eq `'$SenderAddress`'&`$top=500&`$from=$PageNumber"
            }
        }
    }
    else {
        # Build the search query based on specified parameters
        LogVerbose "Creating a query using the search function."
        $UriFilter = "`$search=`"body:$MessageBody`"&`$top=25"
    
        if($null -notlike $SenderAddress){
            if($UriFilter -like '*search*'){
                $UriFilter = $UriFilter.Replace('search="', "search=`"from:$SenderAddress` AND ")
            }
            else{
                $UriFilter = "`$search=`"from:$SenderAddress`"&`$top=25"
            }
        }
    
        if($null -notlike $Subject){
            if($UriFilter -like '*search*'){
                $UriFilter = $UriFilter.Replace('search="', "search=`"subject:$Subject` AND ")
            }
            else{
                $UriFilter = "`$search=`"subject:$Subject`"&`$top=1000&`$select=id,parentfolderid,receivedDateTime,subject,from&`$from=$PageNumber"
            }
        }
    
        if($null -notlike $CreatedBefore){
            $TempStartDate = [datetime]$CreatedBefore
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchBeforeDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if($UriFilter -like '*search*'){
                $UriFilter = $UriFilter.Replace('search="', "search=`"received<=$SearchBeforeDate AND ")
            }
            else{
                $UriFilter = "`$search=`"received<=$SearchBeforeDate`"&`$top=25"
            }
        }
    
        if($null -notlike $CreatedAfter){
            $TempStartDate = [datetime]$CreatedAfter
            $TempStartDate = $TempStartDate.ToUniversalTime()
            $SearchAfterDate = '{0:yyyy-MM-ddTHH:mm:ssZ}' -f $TempStartDate
            if($UriFilter -like '*search*'){
                $UriFilter = $UriFilter.Replace('search="', "search=`"received>=$SearchAfterDate AND ")
            }
            else{
                $UriFilter = "`$search=`"received>=$SearchAfterDate`"&`$top=25"
            }
        }
    }
    return $UriFilter    
}

function BuildSearchReport {
    Log "Creating report with the search results." Cyan
    foreach($result in $Script:SearchResults) {
        $FolderName = ($folderlist | Where-Object {$_.id -eq $result.parentFolderId}).displayName
        $Script:csvOuput = ($result.sender.emailaddress).address + "," + $result.Subject + "," + $result.receivedDateTime + "," + $FolderName
        Add-Content $Script:OutputStream $Script:csvOuput
    }    
}

function ProcessItems {
    Log "Deleting items found within the search results." Green
    foreach($item in $Script:SearchResults) {
        $Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/messages/$($item.id)"
        Send-GraphRequest -Uri $Uri -HttpMethod DELETE | Out-Null
    }
}

###################################
# Declaring Script wide Variables #
###################################

$Date = [DateTime]::Now
$Script:StartTime = '{0:MM/dd/yyyy HH:mm:ss}' -f $Date
$Script:FileName = "GraphSearchAndDelete_$('{0:MMddyyyyHHmms}' -f $Date).csv"
$Script:Scope = "https://graph.microsoft.com/.default"
[int]$PageNumber = 0
$FolderList = New-Object System.Collections.ArrayList
$Script:SearchResults = New-Object System.Collections.ArrayList
$Script:SearchFolderList = New-Object System.Collections.ArrayList

$Uri = "https://graph.microsoft.com/v1.0/users/$Mailbox/mailFolders/messages?"

# Call function to confirm required PowerShell module(s) are installed
Test-InstalledModules

# Call function to create the output file and stream
CreateOutputFile

# Call function to obtain OAuth token
$Script:Token = GetOAuthToken

# Obtain list of mail folders within the mailbox
GetFolderList
#$FolderList | Format-Table displayName,id 

# Perform the search against the mailbox
SearchMailbox

# Build a report of the items
BuildSearchReport
Log([string]::Format("{0} message(s) found using the provided search filters.", $Script:SearchResults.Count)) Green

# Delete the items found using the search criteria
if($DeleteContent) {
    ProcessItems
}